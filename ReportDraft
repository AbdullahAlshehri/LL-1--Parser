
Step I: Scanner

Step II: Parser Generator
	The example we will use for the explanations is:

	Step II(a): Removal of Left Recursion and Common Prefixes
		For this step we transfered the pseudocode from the book to a more object oriented syntax.  The parser generator (ParserGenerator.java) has functions removeSelfLeftRecursion and removeCommonPrefixes which iterates over each nonterminal grammar rule (NonterminalRule.java) and calls their encapsulated functions of the same name (removeSelfLeftRecursion and removeCommonPrefixes).  Within the nonterminal rule rucursion removal and common prefix removal is executed and the functions return a new rule if one was created (ie rule prime).  The parser than adds this rule to the nonterminal rule list and continues.

		Let us consider what would happen if we ran parserGenerator.removeSelfRecursion() on our example grammr.
			parserGenerator would iterate through each nonterminal grammar rule, nonterm, calling nonterm.removeSelfRecursion().
				parserGenerator would first call

		Let us consider what would happen if we ran parserGenerator.removeCommonPrefixes() on our example grammr.
			parserGenerator would iterate through each nonterminal grammar rule, nonterm, calling nonterm.removeCommonPrefixes().
				parserGenerator would first call

	StepII(b): Building First Set, Follow Set, and Parse Table
		Like the previous step, we simply implemented the pseudocode from the book in a more OO way.  

		We calculate the first and follow set using the parser generator's constructFirst and constructFollow functions.  These function iterates over each nonterminal grammar rule and calls their encapsulated functions of the same name (constructFirst and constructFollow).  Within the nonterminal rule the algorithm in the Louden Textbook is executed and a boolean representing whether the individual nonterminal rules' first or follow set was updated.  The parser continues to iterate through the nonterminals until no changes to their first/follow sets occur.

		EXAMPLE FIRST

		EXAMPLE FOLLOW

		Forming the parse table is quite simple after we have the first and follow sets.  We form the parse table by calling the parser generator's createParseTable function.  It simply loops through all the nonterminals and loops through each of the terminals.  If the nonterminal contains the terminal in its first set then the correlating production rule is added to the parse table.  If the nonterminal's first set contains epsilon then epsilon is added to the parse table for all of the follow terminal entries.

		EXAMPLE PARSE TABLE

	Step(c)
		Once we have the parse table parsing is quite simple.  The parser (Parser.java) starts out with an input list, a parse stack that contains only the start symbol, and the parse table.  The parser loops until the stack and input is empty or an error has occured doing the following:
			if the top of the stack is a nonterminal then we add the parse table entry for that nonterminal and the current input symbol to the stack.
			if the top of the stack is a terminal then we make sure that it matches the current input symbol and we pop off the top of the stack and get the next input symbol.
			if any entry in the parse table is empty or the input symbol and stack don't match then we throw an error.

		EXAMPLE PARSER
